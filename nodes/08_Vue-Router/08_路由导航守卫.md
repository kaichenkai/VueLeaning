## 路由导航守卫

### 概念

1. 通过路由守卫可以对每次刷新或进入的路由页面进行权限验证，相当于 Vue 中的全局中间件



### 全局前置守卫

1. 注册一个全局的前置守卫，判断用户是否登录

   在 router.js 中进行设置

   ```vue
   // 设置全局前置守卫
   router.beforeEach((to, from, next) => {
     console.log(from.path, to.path)
   
     if (to.path !== '/login') { // 如果不是访问 /login
       if (window.isLogin) { // 已登录
         next()
       } else { // 未登录
         next('/login?redirect=' + to.path)
       }
     } else {
       next()
     }
   })
   ```

2. login.vue 组件中进行一键登录逻辑处理（伪代码）

   ```vue
   methods: {
     login () {
       window.isLogin = true
       // 做页面跳转
       const redirectUrl = this.$route.query.redirect
       if (redirectUrl) { // 有回调地址
         this.$router.push(redirectUrl)
       } else { // 没有回调地址
         this.$router.replace('/')
       }
     }
   }
   ```

当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于 **等待中**。

每个守卫方法接收三个参数：

- **`to: Route`**: 即将要进入的目标 [路由对象](https://router.vuejs.org/zh/api/#路由对象)
- **`from: Route`**: 当前导航正要离开的路由
- **`next: Function`**: 一定要调用该方法来 **resolve** 这个钩子。执行效果依赖 `next` 方法的调用参数。
  - **`next()`**: 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 **confirmed** (确认的)。
  - **`next(false)`**: 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 `from` 路由对应的地址。
  - **`next('/')` 或者 `next({ path: '/' })`**: 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 `next` 传递任意位置对象，且允许设置诸如 `replace: true`、`name: 'home'` 之类的选项以及任何用在 [`router-link` 的 `to` prop](https://router.vuejs.org/zh/api/#to) 或 [`router.push`](https://router.vuejs.org/zh/api/#router-push) 中的选项。
  - **`next(error)`**: (2.4.0+) 如果传入 `next` 的参数是一个 `Error` 实例，则导航会被终止且该错误会被传递给 [`router.onError()`](https://router.vuejs.org/zh/api/#router-onerror) 注册过的回调。

**确保要调用 `next` 方法，否则钩子就不会被 resolved。**



### 全局后置守卫

你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 `next` 函数也不会改变导航本身

1. 注册一个全局的后置守卫

   ```vue
   router.afterEach((to, from) => {
     // ...
   })
   ```



### 路由独享守卫

你可以在路由配置上直接定义 `beforeEnter` 守卫，这些守卫与全局前置守卫的方法参数是一样的

```vue
const router = new VueRouter({
  routes: [
    {
      path: '/foo',
      component: Foo,
      beforeEnter: (to, from, next) => {
        // ...
      }
    }
  ]
})
```



### 组件内的守卫

概念：可以在组件内部实现相应钩子，在组件内部进行相应守卫

- `beforeRouteEnter`
- `beforeRouteUpdate` (2.2 新增)
- `beforeRouteLeave`

```vue
const Foo = {
  template: `...`,
  beforeRouteEnter (to, from, next) {
    // 在渲染该组件的对应路由被 confirm 前调用
    // 不！能！获取组件实例 `this`
    // 因为当守卫执行前，组件实例还没被创建
  },
  beforeRouteUpdate (to, from, next) {
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 可以访问组件实例 `this`
  },
  beforeRouteLeave (to, from, next) {
    // 导航离开该组件的对应路由时调用
    // 可以访问组件实例 `this`
  }
}
```

